---
title: "Прогнозирование временных рядов с помощью модели ARIMA"
author: "Морозова Ю.А., Баркова З.А."
date: 2017-11-27
output: 
  html_document: 
    toc: true
    toc_float: true
---

# Введение

```{r, warning=FALSE, message=FALSE}
library(tidyverse)
library(lubridate)
library(zoo)
library(forecast)
library(tseries)
library(fpp2)
```

Модель ARIMA сочетает в себе модель авторегрессии порядка *p* (*AR(p)*), являющуюся линейной комбинацией *p* предыдущих значений ряда; и модель скользящего среднего порядка *q* (*MA(q)*), являющуюся линейной комбинацией *q* последних значений шумовой компоненты (ошибки прогноза). В модели *ARIMA(p,d,q)* параметр *d* показывает порядок дифференцирования ряда (здесь дифференцирование - это вычитание с шагом 1, т.е. из текущего значения вычитается предыдущее). В модели *ARIMA(p,d,q)(P,D,Q)* параметры, обозначающиеся заглавными буквами обозначают то же самое, что и маленькими буквами, но для сезонности.

Здесь стоит ввести понятие стационарности временного ряда. Предположение о стационарности включает в себя [следующие условия](https://ru.coursera.org/learn/ekonometrika/lecture/EcjWV/8-1-1-statsionarnyie-i-niestatsionarnyie-riady):

  - математические ожидания значений ряда равны, то есть он не имеет выраженного тренда
  
$$ E(y_1) = E(y_2) = ... =E(y_n) = const$$  

  - дисперсия значений ряда постоянна
  
$$ Var(y_1) = Var(y_2) = ...=Var(y_n)= \gamma_0$$  

  - ковариация (сила линейной связи) между соседними значениями ряда постоянна
  
$$ Cov(y_1,y_2) = ... = Cov(y_{n-1},y_n) = \gamma_1  $$

 - последнее условие можно записать в общем виде для любого шага между значениями - сила линейной связи между значениями отстоящими друг от друга на один и тот же шаг постоянна, то есть эта связь не зависит от времени, а зависит только от "расстояния"" между двумя выбранными точками
 
$$ Cov(y_t,y{t-k}) = \gamma_k$$ 

Существует теорема Вольда, которая гласит, что любой стационарный ряд (распределение значений которого не зависит от времени) может быть описан моделью *ARMA(p,q)*. Соответственно, если ряд имеет тренд либо сезонность (либо и то, и другое), он не является стационарным, а следовательно модель *ARMA(p,q)* не сможет на нем работать.

Рассмотрим несколько временных рядов: 1) данные о ежедневной аренде велосипедов; 2) данные о поголовье рыси по годам; 3) данные о пассажирообороте на американских авиалиниях по месяцам.

```{r Загрузка данных} 
bike <- read.csv('data/day.csv') #чтение файлов данных
passml <- read.csv('data/monthly-us-air-passenger-miles-j.csv')
```

```{r Преобразование дат}
bike$dteday = as.Date(bike$dteday) #приведение даты к нужному формату
passml$date = as.yearmon(passml$Month)
```

```{r, warning=FALSE, message=FALSE}
ggplot(bike, aes(dteday, cnt)) + #построение графиков
  geom_line() + 
  labs(title="Динамика количества арендованных велосипедов по дням") +
  ylab("Количество случаев аренды велосипедов") +
  xlab("День")

autoplot(lynx) + 
  labs(title ="Динамика изменения поголовья рыси по годам") +
  ylab("Количество особей рыси") +
  xlab("Год")

ggplot(passml, aes(date, Passenger_miles)) + 
  geom_line() + 
  labs(title = "Динамика пассажирооборота на авиалиниях США по месяцам") +
  ylab("Пассажиро-мили") +
  xlab("Год")

```

Временной ряд для аренды велосипедов будет нестационарным из-за наличия тренда, временной ряд изменения пассажирооборота на авиалиниях также является нестационарным, так как ярко выражен как тренд, так и сезонность, а кроме того, дисперсия значений ряда увеличивается со временем, временной ряд изменения поголовья рыси является стационарным, поскольку в нем нет тренда и сезонности. 

Далее будем рассматривать построение моделей на примере временного ряда о пассажирообороте на авиалиниях США. График выглядит довольно "аккуратно", выбросов на нем не видно. Если бы были выбросы, можно было бы сгладить выбросы с помощью функции `tsclean()` из библиотеки `forecast`. 

Проверим ряд на наличие пропущенных значений:

```{r Проверка наличия пропущенных значений}
sum(is.na(passml$Passenger_miles))
```

# Компоненты ряда

Временной ряд может включать в себя несколько компонентов (не всегда включает все). Есть 4 основных составляющих временного ряда - тренд, сезонность, циклическая компонента и шумовая компонента. Разложим рассмариваемый ряд на составные части:

```{r Сезонная декомпозиция}
pmiles <- ts(na.omit(passml$Passenger_miles), frequency=12)
decomp <- stl(pmiles, s.window="periodic")
deseasonal_cnt <- seasadj(decomp)
autoplot(decomp) +
  labs(title = "Декомпозиция временного ряда",
       x = "Время")
```

# Как сделать временной ряд стационарным

## Проверка на стационарность

Чтобы применить модель ARIMA на нашем временном ряде, необходимо привести его к стационарному виду. Как было видно и до, и после деления ряда на составляющие, наш ряд делают нестационарным три основные вещи: 1) тренд, 2) сезонность, 3) рост дисперсии сезонного размаха. К этому заключению мы пришли после визуального анализа, но нужно что-то более конкретное, чтобы убедиться, стационарен наш ряд или нет.

Для этого случая существует статистический [критерий Дики-Фуллера](https://en.wikipedia.org/wiki/Dickey-Fuller_test). В качестве нулевой гипотезы обычно рассматривается гипотеза о нестационарности ряда, в качестве альтернативы - то, что ряд стационарен. Соответственно, мы сможем отвергнуть гипотезу о нестационарности временного ряда в том случае, если p-value < 0.05 (при 95% уровне значимости). 

*Критерий Дики-Фуллера:*

Временной ряд: $y^T = y_1,..., y_T$ ;

Нулевая гипотеза: $H_0:$ ряд нестационарен;

Альтернативная гипотеза: $H_1:$ ряд стационарен.
  

В данном примере будем использовать расширенный тест Дики-Фуллера (augmented Dikey-Fuller test), имеющийся в библиотеке `tseries`. Однако, у этого теста есть особенность в том, что сезонность ряда как-то влияет на его результат (именно в реализации на R). Поскольку у нас период составляет год, то укажем, что в периоде 12 месяцев.

```{r Расширенный тест Дики-Фуллера}
adf.test(pmiles, k=12, alternative = "stationary")
```

Итак, тест показал, что ряд нестационарен.

## Сглаживание дисперсии сезонных колебаний

Превое, что можно сделать с рядом, это сделать ровнее размах сезонных колебаний. Для того чтобы сгладить увеличение размаха сезонных колебаний временного ряда, обычно используют либо логарифмирование, либо [преобразование Бокса-Кокса](https://en.wikipedia.org/wiki/Power_transform). В этом примере будем использовать логарифмирование, так как оно проще.

*Преобразование Бокса-Кокса:*

$$ y_t' =  
\begin{cases}
 ln y_t  & \lambda=0 \\
 (y^\lambda_t -1)/\lambda & \lambda \neq0
\end{cases} $$

В этом преобразовании необходимо подбирать параметр $\lambda$.

*Логарифмирование:*

$$y_t' = ln y_t $$


```{r Логарифмирование}
passml$lnpml <- log(passml$Passenger_miles)
```


```{r Логарифмированный ряд на графике, warning=FALSE, message=FALSE}
ggplot(passml, aes(date, lnpml)) + 
  geom_line() + 
  labs(title = "Логарифм пассажирооборота на авиалиниях США") +
  ylab("Логарифм пассажиро-миль") +
  xlab("Месяц")
```

```{r Тест Дики-Фуллера к логарифмированному ряду}
adf.test(passml$lnpml, k = 12, alternative = "stationary")
```

На графике видно, что размах колебаний стал ровнее, чем был, но по критерию Дики-Фуллера ряд все равно не стационарен.

## Сезонное дифференцирование

Обычно чтобы привести ряд к стационарному виду применяют дифференцирование (сезонное, если есть сезонность и простое, чтобы избавиться от тренда). Начнем с сезонного дифференцирования, может быть, простое уже не понадобится.

```{r Сезонное дифференцирование}
deseasonal <- diff(passml$lnpml, lag = 12, differences = 1)
```

В данном случае используем функцию `plot`, так как функция `autoplot` принимает на вход только объекты класса `survfit`.

```{r График ряда после сезонного дифференцирования, warning=FALSE, message=FALSE}
plot(passml$date[c(13:length(passml$lnpml))], deseasonal, type = "l",
     main = "Логарифм пассажирооборота без сезонной компоненты", xlab = "Месяц",
     ylab = "Логарифм пассажиро-миль без сезонных изменений") 
```

```{r Тест Дики-Фуллера после сезонного дифференцирования}
adf.test(deseasonal, alternative = "stationary")
```

После сезонного дифференцирования на графике уже не видно "сезонного паттерна", а p-value критерия Дики-Фуллера значительно уменьшилось. Но попробуем все же еще провести и простое дифференцирование.

## Простое дифференцирование

Чтобы в избавиться от тренда временного ряда проведем дифференцирование с лагом 1.

```{r Простое дифференцирование}
detrended <- diff(deseasonal, lag = 1, differences = 1)
```

```{r График временного ряда без сезонной компоненты и тренда, warning=FALSE, message=FALSE}
plot(passml$date[c(14:length(passml$lnpml))], detrended, type = "l",
     main = "Логарифм пассажирооборота без сезонной компоненты и тренда",
     xlab = "Месяц",
     ylab = "Логарифм пассажиро-миль без тренда и сезонности") 
```

```{r Тест Дики-Фуллера для ряда без сезонной компоненты и тренда}
adf.test(detrended, alternative = "stationary")
```

Отлично! Теперь на графике виден стационарный ряд, что подкрепляется результатом теста Дики-Фуллера. Сделав сезонное и простое дифференцирование мы подобрали уже два параметра для модели *ARIMA(p,**d**,q)(P,**D**,Q)* (выделенные жирным). То есть большое *D* - это порядок сезонного дифференцирования (у нас единица, так как вычитали один раз), а маленькое *d* - это порядок обычного дифференцирования (тоже единица).

# Подбор параметров модели

Для того чтобы подобрать начальное приближение остальных параметров модели, обычно пользуются коррелограммами, показывающими автокорреляцию и частичную автокорреляцию.

```{r}
Acf(detrended, lag.max = 48, main='Автокорреляция дифференцированного ряда')
Pacf(detrended, lag.max = 48, main='Частичная автокорреляция дифференцированного ряда')
```

Начальное приближение параметров подбирают следующим образом:  

  - Q - номер последнего сезонного лага (по порядку) со значимой автокорреляцией  −> *Q = 1*  
  
  - q - номер последнего несезонного лага со значимой автокорреляцией  −> *q = 2*  
  
  - P - номер последнего сезонного лага со значимой частичной автокорреляцией  −> *P = 2*  
  
  - p - номер последнего незезонного лага со значимой частичной автокорреляцией  −> *p = 3*  



# Выбор модели

Обратите внимание, что на вход модели мы будем подавать исходный временной ряд, только логарифмированный (без дифференцирования), порядок дифференцирования укажем как входной параметр.

```{r Создание вектора данных}
lnpml <- passml$lnpml
```

Функция `auto.arima()` в принципе может сама подбирать параметры при заданных ограничениях, однако, мы укажем найденные начальные приближения параметров в качестве максимально возможных, а также зададим исходные параметры (с которых модель начнет обучаться) единицами.

Качество модели оценивается либо информационным критерием Акаике (AIC), либо Байесовским информационным критерием (BIC). Оба эти критерия очень похожи, можно выбирать любой. Чем меньше значение критерия, тем лучше модель.

Обучим модель:

```{r Построение модели ARIMA}
fit1 <- auto.arima(lnpml, d = 1, D = 1, max.p = 3, max.q = 2, max.P = 2,
  max.Q = 1, max.order = 10, seasonal = TRUE, ic = "aic", stepwise = FALSE,
  parallel = FALSE)
fit1
```

Как видно из результатов, все что касается сезонной компоненты было опущено. Однако, как мы видели на графике, сезонность точно присутствовала в модели. Попробуем самостоятельно методом перебора подобрать сезонные параметры. Порядок дифференцирования уже подобран - 1, для двух остальных пройдемся циклом от нуля до максимального значения, найденного по кореллограммам.

```{r Подбор параметров модели ARIMA}
for (P in c(0, 1, 2)){
  for (Q in c(0, 1)){
    cat("P=",P,"Q=",Q)
    print(arima(lnpml, order = c(2, 1, 1),
      seasonal = list(order = c(P, 1, Q), period = 12)))
  }
}
```

Ориентируясь на критерий информативности Акаике (он минимизируется), найлучшей моделью оказывается следующая: ARIMA(2,1,1)(0,1,1). Сохраним эту модель.

```{r Подобранная модель}
fit2 <- arima(lnpml, order = c(2, 1, 1),
      seasonal = list(order = c(0, 1, 1), period = 12))
fit2
```

# Анализ остатков модели

Чтобы понять, действительно ли хороша модель, посмотрим на ее остатки.

```{r Анализ остатков модели}
tsdisplay(residuals(fit2), lag.max = 48, main = "Остатки модели ARIMA (2,1,1)(0,1,1)")
```

Какими должны быть хорошие остатки модели? Они должны быть независимыми (смотрим, чтобы лаги на коррелограммах не выходили за пределы доверительных интервалов для нулевых значений, т.е. были незначимыми) и в среднем равны нулю (что наблюдается на первом графике).

Также посмотрим и на остатки первой модели, где не учитывался сезонный фактор:

```{r Анализ остатков модели без учета сезонности}
tsdisplay(residuals(fit1), lag.max = 48, main = "Остатки модели ARIMA (2,1,1)")
```

В данном случае на коррелограммах явно видно, что остатки не независимы.

# Прогноз

Посмотрим на двухлетний прогноз прологарифмированного ряда (параметр `h` функции `forecast` отвечает за число периодов, на которые надо прогнозировать).

```{r Построение прогноза}
lnfcst <- forecast(fit2, h =24)
autoplot(lnfcst, main = "Прогноз для логарифмированного ряда") +
         labs(x = "Номер периода",
         y = "Логарифм пассажиро-миль",
         fill = "Доверительный интервал")
```

Выглядит нормально. Теперь надо привести прогноз в нужный вид, то есть провести операцию, обратную натуральному логарифмированию - это возведение числа *е* в степень:

$$ y_f = e^{y_f'}$$

```{r Построение прогноза исходного ряда}
fcst <- exp(lnfcst$mean)
```

Построим на графике исходный ряд и прогноз.

```{r Сопоставление исходного ряда и прогноза}
plot(c(passml$Passenger_miles,fcst), type = "l",
     main = "Прогноз пассажирооборота на 2 года (24 периода)",
     xlab = "Номер периода", ylab = "Пассажиро-мили")
lines(fcst, col = "blue")
```

Похоже, что прогнозные значения довольно неплохо повторяют тенденции исходного временного ряда.






























