---
title: "Технические вопросы работы с временными рядами"
author: "Заходякин Г.В., postlogist@gmail.com"
output: 
  html_document: 
    number_sections: no
    toc: yes
    toc_float: yes
    toc_depth: 3
---

# Введение

В этом блокноте рассмотрены различные технические вопросы работы с временными рядами в R:

  - как получить временной ряд из табличных данных,  
  - как сохранить прогноз в файл,
  - как получить временной ряд на основе транзакционных данных.

Настройка вывода:

```{r Настройка, include=TRUE}
options(digits = 3) # Количество значащих цифр при выводе
```

Подключение пакетов:

```{r Подключение библиотек, warning=FALSE, message=FALSE}
library(zoo) # работа с высокочастотными временными рядами, в этом блокноте используется только функция сохранения ряда в файл
library(tidyverse) # визуализация и трансформация данных
library(forecast) # анализ временных рядов и прогнозирование
library(lubridate) # работа с датами
```

# Как сделать временной ряд `ts`

В R есть несколько структур данных для хранения временных рядов. Пакет `forecast` может работать только с временными рядами класса `ts`. Поэтому, если вы хотите его использовать, потребуется преобразовать данные в этот формат.

В качестве примера возьмем временной ряд с ежемесячными продажами шампанского, полученный из репозитория [DataMarket](https://datamarket.com/data/set/22qf/monthly-champagne-sales-in-1000s-p273-montgomery-fore-ts)


```{r Загрузка и контроль набора данных, message=FALSE, warning=FALSE}
champ_tbl <- read_csv2('data/monthly_champagne_sales_in_1000s.csv', comment = '#')
head(champ_tbl)
```

**Примечание:** в файле первые несколько строк - комментарии, помеченные символом `#` в начале строки, поэтому в функции для считывания данных надо указать символ для комментария как аргумент.

Видим два столбца - текстовый, содержащий номер периода и числовой, с объемом продаж в тысячах единиц. Для удобства дальнейшей работы, поменяем имена столбцов на более короткие:

```{r Переименование столбцов}
names(champ_tbl) <- c('period', 'sales')
head(champ_tbl, 3)
```

Также видно, что в таблице данных нет дат, указаны лишь порядковый номер года в истории наблюдений и номер месяца, причем в одном текстовом столбце. Для удобства, разделим эти компоненты на отдельные столбцы с помощью функции `dplyr::separate()`:

```{r Разделение номера периода на компоненты}
champ_tbl2 <- champ_tbl %>%
  separate(period, into = c('year', 'month'), sep = '-', convert = TRUE)

head(champ_tbl2)
```


Временной ряд `ts` состоит из вектора наблюдений и индекса. В качестве индекса используется возрастающая последовательность чисел (обычно это годы). Если ряд содержит более частые наблюдения - например, ежемесячные или ежеквартальные, то необходимо задать **частоту** ряда (*frequency*), т.е. количество наблюдений в течение года.

В данном примере вместо года придется использовать порядковый номер. Частота равна 12, т.к. данные ежемесячные.


```{r Подготовка временного ряда}
champ <- ts(data = champ_tbl2$sales, 
            start = first(champ_tbl2$year), 
            frequency = 12)

champ
```

**Примечания:** 

  - Если наблюдения начинаются не с первого месяца года, то начало ряда следует задавать так:
  `start = c(год, месяц)`
  
  - В качестве сезонного цикла не обязательно использовать год. Например, можно работать с ежедневными данными, задав частоту 7, или с ежечасными наблюдениями, задав частоту 24. В этом случае, к сожалению, даты будут отражаться на визуализациях некорректно, придется принимать меры.


```{r Вывод наблюдений временного ряда}
champ_title <- 'Ежемесячные продажи шампанского'
champ_unit <- 'Тыс. ед.'
autoplot(champ) +
  labs(title = champ_title, y = champ_unit, x = NULL) #в виде графика
```

Временной ряд `ts` представляет собой сочетание последовательности наблюдений и индекса, который соотносит наблюдения с некоторым календарным периодом. Индекс для временного ряда `ts` - это действительное число, целая часть которого соответствует году, а дробная - месяцу. Так, для января 2017 года индекс будет `2000.0`, для февраля - на `1/12` больше - `2000.083` и т.д.

При необходимости, можно извлечь эти компоненты с помощью функций `coredata()` и `index()` соответственно. Частоту ряда можно получить с помощью функции `frequency()`. 

Такое может потребоваться, например, для преобразования временного ряда `ts` в обычную таблицу `tibble`.

```{r Извлечение компонентов объекта ts}
index(champ) %>% head() # Индекс

coredata(champ) %>% head() # Наблюдения

frequency(champ) # Частота ряда

(index(champ) * frequency(champ)) %% frequency(champ) + 1 # Номер месяца по индексу
    
```

# Как сохранить прогноз в файл

Получим прогноз на 24 месяца по модели Винтерса:

```{r Прогнозирование продаж шампанского}

champ_fc <- hw(champ, h = 24)$mean
champ_fc
class(champ_fc)
```

## Сохранение в двоичном формате RDS

Полученный объект также имеет тип `ts`. Такие данные (как и любой объект R) можно сохранить в двоичном формате `RDS` при помощи функции `saveRDS()`:

```{r Сохранение в двоичном формате}
# Сохранение в файл
champ_fc %>% saveRDS(file = 'data/champ_fc.RDS')
# Считывание из файла
champ_fc2 <- readRDS('data/champ_fc.RDS')
```

Файлы RDS удобны для последующей обработки данных в R, поскольку они очень быстро считываются. Однако если предполагается использовать данные в других программах, потребуется сохранить данные в текстовый файл. Этот формат удобно использовать для обмена между программами.

## Сохранение в текстовый файл - через `zoo`

Наиболее простой способ сохранить данные в текстовый файл - через функцию `zoo::write.zoo()`. 

Эта функция автоматически преобразует временной ряд `ts` в формат `zoo`, который используется в одноименном пакете.

```{r Сохранение в текстовый файл при помощии zoo}
champ_fc %>% write.zoo(file = 'data/champ_fc.csv', col.names = c('index', 'forecast'))
```

К недостаткам этого подхода можно отнести неудобный формат индекса. Это не даты, а годы + доли года, соответствующие каждому периоду.

Для максимальной гибкости, можно преобразовать данные в таблицу и в дальнейшем работать с ней.

## Сохранение в текстовый файл - через таблицу

В таблице необходимо отразить дату, соответствующую началу периода, а также само значение прогноза на период. С самим прогнозом проблем нет, а вот дату потребуется сформировать на основе индекса. Для ежемесячных данных удобно использовать функцию `lubridate::make_date()`, которая собирает дату из трех компонентов - год, месяц и день. Номер года можно получить, округлив индекс (он имеет вид: 2017.5) в меньшую сторону. Номер месяца - взяв дробную часть года.

```{r Преобразование в таблицу}
# Функция для преобразования индекса в номер периода в сезонном цикле
i2p <- function(x) {
  (index(x) * frequency(x)) %% frequency(x) + 1 # Номер периода по индексу
}

# Функция для преобразования индекса в дату (только для ежемесячных рядов)
i2month <- function(x) {
  make_date(year = floor(index(x)),
            month = i2p(x))
} 

# Создаем таблицу
champ_fc_tbl <- 
  tibble(period = i2month(champ_fc),
         forecast = round(coredata(champ_fc)))

# Что получилось
champ_fc_tbl %>% head()

```

Для визуализации табличных данных можно использовать все возможности `ggplot2`.

```{r}
champ_fc_tbl %>%
  ggplot(aes(period, forecast)) +
  geom_line() +
  labs(title = paste(champ_title, '(прогноз)'), 
       x = NULL, y = champ_unit)
```

Сохранить данные в файл можно, например, при помощи функции `write.csv2()`:

```{r}
champ_fc_tbl %>% write.csv2(file = 'data/champ_fc_tbl.csv', row.names = FALSE)
```

# Как получить временной ряд из транзакционных данных

Пакет `forecast` работает только с регулярными временными рядами, в которых наблюдения идут через одинаковые интервалы времени. В то же время, в компаниях данные накапливаются в виде транзакций (заказов, отгрузок и т.п.). Чтобы получить из них временной ряд, необходимо агрегировать данные.

В качестве примера рассмотрим данные о продажах строительных материалов (по дням/отдельным товарам).

```{r Загрузка транзакционных данных, warning=FALSE, message=FALSE}
sales <- read_csv2(file = 'data/materials.csv')
head(sales)
```


В качестве примера возьмем наиболее ходовой товар в категории `Грунтовка`:

```{r}
sales %>% filter(`Группа` == 'Грунтовка') %>% group_by(`Товар`) %>%
  summarise(`Количество` = sum(`Количество`)) %>% arrange(desc(`Количество`))
```

Таким товаром оказалась грунтовка ГФ-021 (`Грунтовка алкидная ГФ-021 ТЕКС Универсал красно-коричневая, 2.5 кг, шт`)

Отберем данные только по одному товару и сгруппируем продажи по месяцам. Для выделения месяца, воспользуемся функцией `lubridate::floor_date()`, которая округляет даты с заданной точностью:


```{r Агрегирование данных}

sales_monthly_tbl <- sales %>%
  filter(`Товар` == 'Грунтовка алкидная ГФ-021 ТЕКС Универсал красно-коричневая, 2.5 кг, шт' ) %>%
  mutate(`Месяц` = floor_date(dmy(`Дата`), unit = 'month')) %>%
  group_by(`Месяц`) %>%
  summarise(`Количество` = sum(`Количество`)) %>%
  arrange(`Месяц`)

head(sales_monthly_tbl)

```


Визуализация ряда:

```{r}
sales_monthly_tbl %>%
  ggplot(aes(`Месяц`, `Количество`)) +
    geom_line()
  
```

В данном случае ряд продаж не содержит пропусков. Однако часто товар не продается в течение нескольких периодов (например, из-за out-of-stock). В этом случае периоды без продаж не будут присутствовать в данных, и их нужно обязательно восстановить (заполнить нулями или "восстановленными" значениями). 
Эту задачу можно решить, создав таблицу, в которой будут присутствовать все периоды и "подтянуть" туда фактические данные.

```{r Восстановление дат}

# Все месяцы в диапазоне
all_dates <- seq(from = min(sales_monthly_tbl$`Месяц`),
                 to = max(sales_monthly_tbl$`Месяц`),
                 by = '1 month')

# Делаем таблицу, добавляем известные данные (левое соединение)
all_dates_tbl <- tibble(`Месяц` = all_dates) %>%
  left_join(sales_monthly_tbl, by = 'Месяц')

# Если были пропуски - заполняем нулями
all_dates_tbl_fixed <- all_dates_tbl %>%
  mutate(`Количество` = coalesce(`Количество`, 0))

```

Если бы в данных были пропуски, то после слияния таблиц им бы соответствовали пустые значения, которые можно заменить на 0 при помощи функции `dplyr::coalesce()`.

Теперь можно сделать из данных временной ряд `ts` и сделать прогноз.

```{r}
# Начало ряда
first_year <- all_dates_tbl_fixed$Месяц %>% year() %>% first()
first_month <- all_dates_tbl_fixed$Месяц %>% month() %>% first()

# Создаем временной ряд
grunt_ts <- ts(all_dates_tbl_fixed$Количество,
               start = c(first_year, first_month),
               frequency = 12)

# Что получилось
grunt_ts
autoplot(grunt_ts)
```

Прогноз

```{r}

# Прогноз
grunt_m <- ets(grunt_ts, model = 'ZNM')
grunt_fc <- forecast(grunt_m, h = 24)

autoplot(grunt_fc)

```

# Временные ряды и tidyverse

R непрерывно развивается и участники сообщества постоянно создают новые пакеты. Так, в 2017 году в CRAN были добавлены пакеты, позволяющие работать с временными рядами, используя табличный формат данных.

С ними можно познакомиться здесь:

 - `timetk` - для преобразования временных рядов в таблицы и обратно - https://business-science.github.io/timetk/ 
 
 - `sweep` - для преобразования моделей временных рядов и прогнозов по ним в таблицы - https://business-science.github.io/sweep/
 
 - `tidyquant` - для работы с финансовыми временными рядами - https://business-science.github.io/tidyquant/

