---
title: "Исследование структуры временных рядов в R (альтернативная версия)"
author: "Заходякин Г.В., postlogist@gmail.com"
output: 
  html_document: 
    number_sections: no
    toc: yes
    toc_depth: 2
---


# Введение

В этом блокноте разобраны примеры анализа регулярных временных рядов из Единой межведомственной информационной системы (http://fedstat.ru) и Росстата (http://gks.ru).

Пример анализа временных рядов из Единого архива экономических и социологических данных НИУ ВШЭ (http://sophist.ru)  рассмотрены в файле `decomposition_tutorial.Rmd`. 

Рекомендуем также ознакомиться со следующими примерами:

 - [time_series.Rmd](time_series.Rmd) - загрузка и сохранение данных временного ряда  
 - [dygraphs_tutorial.Rmd](dygraphs_tutorial.Rmd) - визуализация временных рядов с возможностью интерактивного исследования данных
 
 

```{r Подключение библиотек, message=FALSE, warning=FALSE}
library(tidyverse) # ggplot2 и трансформация данных
library(readxl) # Загрузка экселей
library(forecast) # анализ временных рядов и прогнозирование
library(lubridate) # операции с датами
#library(stringr)  # Работа с текстовыми строками
```

# Подготовка данных
## Как загрузить данные из Excel

Исходный файл данных - Оборот розничной торговли в Российской Федерации [data/fedstat_retail.xls](./data/fedstat_retail.xls),
название листа - `Данные`.

Источник - [система ЕМИСС](https://fedstat.ru/indicator/31260)

Единица измерения - млн руб.


```{r}
retail_raw <- read_excel('fedstat_retail.xls', 
                       sheet = 'Данные',
                       skip = 2 # Пропустить 2 строки вверху листа
)
head(retail_raw)
```

Данные загрузились как числовые значения. В файле содержатся ежемесячные наблюдения начиная с января 2000 года. Исправим имена столбцов:

```{r}
names(retail_raw) <- c('metric', 'year', 'month', 'turnover')
head(retail_raw)
```

Для визуализации данных средствами ggplot получим столбец с датами наблюдений на основе имеющихся столбцов с годом и месяцем. Наблюдение отнесем к 1 числу месяца. Удалим лишние столбцы `metric`. Пересчитаем оборот из млн руб. в млрд руб.

```{r}
retail_tbl <- 
  retail_raw %>%
  mutate(date = ymd(paste(year, month, 1))) %>%
  select(date, turnover) %>%
  mutate(turnover = turnover / 1000)
retail_tbl %>% head()
```

Полученную таблицу данных можно визуализировать средствами ggplot, чтобы проверить, нет ли в ней пропусков. Дальнейшая работа с данными ряда требует, чтобы наблюдения были регулярными, без пропущенных периодов.

```{r}
# Запоминаем название ряда и источник для графиков
retail_title <- 'Оборот розничной торговли в РФ, млрд руб'
retail_source <- 'Источник данных - ЕМИСС'
# Визуализация
retail_tbl %>%
  ggplot(aes(date, turnover)) +
  geom_line() +
  labs(title = retail_title,
       caption = retail_source,
       y = NULL, x = NULL)
```


## Как сделать временной ряд `ts`

В R есть множество форматов представления временных рядов. Инструменты для анализа временных рядов из базового R и из пакета `forecast` работают только с регулярными временными рядами класса `ts`.

Временной ряд `ts` состоит из **наблюдений** и **индекса**. В качестве индекса используется возрастающая последовательность чисел (обычно это годы). Если ряд содержит более частые наблюдения - например, ежемесячные или ежеквартальные, то необходимо задать **частоту** ряда (*frequency*), т.е. количество наблюдений в течение года.

При создании ряда необходимо указать, что данные начинаются с 1 месяца 2000 года, а частота равна 12, т.к. данные ежемесячные.

```{r Определения начала наблюдений}
# Найдем автоматически год и месяц начала наблюдений:
retail_first <- 
  retail_tbl %>%
  summarize(year = year(first(date)),
            month = month(first(date)))
retail_first
```

Создадим временной ряд ts. Для этого укажем столбец с данными, начальный период - (год, месяц) и частоту (12).

```{r}
retail_ts <- 
  ts(data = retail_tbl$turnover, 
            start = c(retail_first$year, retail_first$month), 
            frequency = 12)
retail_ts %>% tail(n = 21) %>% round()
```

# Анализ временного ряда

## Визуализация

Функции базовой графики R могут работать с временными рядами `ts` непосредственно. Для визуализации временного ряда средствами `ggplot2` необходимо использовать функцию `autoplot()` пакета `forecast`. В результате получается объект, с которым можно продолжить работу стандартными средствами `ggplot2`.

```{r Визуализация}
autoplot(retail_ts) +
  labs(title = retail_title, caption = retail_source, x = NULL, y = NULL) +
  geom_line(color = 'lightSkyblue')
```

Справку по использованию функции можно получить командой: `?autoplot.ts` или [онлайн](https://www.rdocumentation.org/packages/forecast/versions/8.9/topics/autolayer.mts).


## Классическая сезонная декомпозиция

Декомпозиция временного ряда позволяет выделить отдельные его компоненты - тренд, сезонность и нерегулярные изменения (остаток). 

Форма графика временного ряда позволяет предположить наличие тренда и сезонных колебаний мультипликативного типа.

Вначале воспользуемся встроенной функцией R - `decompose()`, реализующей метод классической декомпозиции на основе скользящего среднего. Визуализировать результаты можно с помощью функции `autoplot()`

```{r Классическая декомпозиция}
retail_d <- retail_ts %>% 
  decompose(type = 'multiplicative')
autoplot(retail_d) +
  labs(title = 'Компоненты временного ряда (классическая декомпозиция)',
       x = NULL)
```

Результат декомпозиции имеет множество применений, например:

 - Легче сравнивать временные ряды, если исключить сезонные изменения.  
 - Легче выявлять нерегулярные изменения, не укладывающиеся в регулярные сезонные колебания.  
 - Можно скомбинировать компоненты, чтобы получить прогноз.  
 - После исключения сезонности и/или тренда из временного ряда результат можно описать с помощью более простой модели. Получив прогноз с помощью более простой модели, можно "вернуть" исключенные компоненты.  
 - Данные о сезонности гораздо более устойчивы, чем данные о тренде. Это может быть полезно при прогнозировании в кризисный период: сезонность сохраняется, а направление тренда резко изменяется из-за спада в экономике.  

Для извлечения компонентов ряда можно использовать их имена (`x` - исходный ряд, `seasonal` и `trend` - закономерные компоненты, `random` - остаток):

```{r Компоненты объекта при использовании классической декомпозиции}
names(retail_d)
```

Однако удобнее пользоваться специальными функциями пакета `forecast`:

```{r Извлечение компонентов ряда при помощи функций}
# Сезонные индексы
retail_d %>% seasonal() %>% head(12) %>% round(1)
# Тренд-циклическая компонента
retail_d %>% trendcycle() %>% head(12) %>% round(1)
# Остаток
retail_d %>% remainder() %>% head(12) %>% round(1)
```


Рассмотрим отдельно компоненты ряда. Для сравнения, будем изображать компоненты поверх исходного ряда

**Тренд**

```{r Тренд, warning=F, message=F}
autoplot(retail_ts, series = 'Оригинал') +
  autolayer(trendcycle(retail_d), series = 'Тренд') +
  labs(color = NULL, x = NULL, y = NULL, 
       title = retail_title) +
  scale_color_manual(values = c('lightskyblue', 'red')) +
  scale_x_continuous(minor_breaks = start(retail_ts):end(retail_ts))
```

Обратим внимание на то, что линия тренда короче исходного ряда. Это вызвано тем, что функция `decompose()` использует для выделения тренда скользящее среднее с окном, равным частоте временного ряда (12). В результате, по 6 периодов в начале и в конце ряда теряются, т.к. скользящее окно усреднения выходит в эти периоды за пределы данных и среднее не может быть вычислено.

На графике трендциклической компоненты виден спад во время кризисов 2008 и 2015 года.

**Сезонный компонент**

```{r Сезонный компонент, message=F, warning=F}
autoplot(seasonal(retail_d)) +
  labs(y = NULL, x = NULL,
       title = 'Сезонные коэффициенты') +
  scale_x_continuous(minor_breaks = start(retail_ts):end(retail_ts))
```

В методе классической декомпозиции сезонные коэффициенты получаются с помощью усреднения наблюдений для одноименных месяцев после удаления тренда, поэтому наборы сезонных коэффициентов для всех лет одинаковы.

**Модель ряда**

Модель ряда получается путем сочетания выделенных закономерных компонентов. Сравним результат с исходными данными.

```{r Модель ряда, message=F, warning=F}
autoplot(retail_ts, series = 'Оригинал') +
  autolayer(trendcycle(retail_d) * seasonal(retail_d),
            series = 'Модель') + 
  scale_colour_manual(values = c('dodgerblue', 'lightskyblue')) +
  labs(y = NULL, color = NULL, x = NULL,
       title = retail_title)
```

Результат близок к оригиналу, однако виды расхождения. Эти расхождения - **остатки**, или ошибки модели. Их также называют нерегулярным (случайным) компонентом ряда.

**Остатки**

```{r Нерегулярный компонент, message=F, warning=F}
autoplot(remainder(retail_d)) +
  labs(y = NULL, x = NULL,
       title = 'Нерегулярный компонент ряда') +
  scale_x_continuous(minor_breaks = start(retail_ts):end(retail_ts))
```

Заметны регулярные колебания остатков, следовательно, закономерные компоненты исключены не полностью. Это - следствие того, что на протяжении выбранного для анализа периода величина сезонных коэффициентов менялась, но классическая декомпозиция не позволила этого учесть. Следовательно, необходимо использовать другой метод и/или сократить количество наблюдений временного ряда.



## Сезонная корректировка ряда

Сезонная корректировка ряда позволяет исключить влияние сезонных колебаний. Это облегчает анализ краткосрочных изменений ряда, которые иначе не видны из-за сезонности. Для выполнения сезонной корректировки в R можно использовать функцию `forecast::seasadj()`. Эта функция принимает в качестве аргумента объект, созданный одной из функций для декомпозиции.

```{r Сезонная корректировка, message=F, warning=F}
retail_adj <- seasadj(retail_d)
autoplot(retail_ts, series = 'Оригинал') +
  autolayer(trendcycle(retail_d), series = 'Тренд') +
  autolayer(retail_adj, series = 'СС ряд') + 
  scale_colour_manual(values = c('lightskyblue', 'brown', 'red')) +
  labs(y = NULL, color = NULL, x = NULL, 
       title = retail_title) +
  scale_x_continuous(minor_breaks = start(retail_ts):end(retail_ts))
```

В отличие от сильно сглаженной линии тренда, график сезонно-скорректированный ряд содержит случайные колебания уровня. Наш ряд имеет мультипликативную структуру, поэтому его модель может быть описана формулой:

$$ y = T \cdot S \cdot E, $$

где $T$ - тренд, $S$ - сезонный коэффициент, $E$ - случайная (нерегулярная) составляющая, или ошибка, $y$ - наблюдаемое значение ряда.

Тренд - это только компонент $T$, а ряд с исключенной сезонностью получается с помощью деления:

$$ A = \frac{y}{S} = T \cdot E. $$

В отличие от тренда, временной ряд с удаленной сезонностью содержит случайную составляющую $E$.


Аналогичного результата можно добиться и с помощью непосредственного деления исходного ряда на сезонные коэффициенты:

```{r Сезонная корректировка вручную, message=F, warning=F}
autoplot(retail_ts, series = 'Оригинал') +
  autolayer(trendcycle(retail_d), series = 'Тренд') +
  autolayer(retail_adj, series = 'СС ряд') +
  autolayer(retail_ts/seasonal(retail_d), series = 'СС ряд, расчет') + 
  scale_colour_manual(values = c('lightskyblue', 'brown', 'orange', 'red')) +
  labs(y = NULL, color = NULL, x = NULL, 
       title = retail_title) +
  scale_x_continuous(minor_breaks = start(retail_ts):end(retail_ts))
```

Ряд с исключенной сезонностью содержит значения во всех периодах, т.к. для его вычисления используются непосредственно значения исходного ряда и сезонные коэффициенты. Сезонные коэффициенты - одни и те же для всех лет временного ряда, поэтому пустых периодов данных нет.


## Исключение тренда

Подобным же образом, можно удалить из ряда тренд, чтобы облегчить анализ изменений сезонного цикла.


```{r Удаление тренда, message=F, warning=F}
retail_detrended <- retail_ts/trendcycle(retail_d)
autoplot(retail_detrended) +
  labs(y = NULL, color = NULL, x = NULL, 
       title = 'Ряд с удаленным трендом') +
  scale_x_continuous(minor_breaks = start(retail_ts):end(retail_ts))
```


В пакете `forecast` имеется функция для визуализации отличий сезонных колебаний в разные годы - `ggseasonplot()`. В зависимости от задачи, более наглядным может оказаться применение этой функции к ряду с удаленным трендом.

```{r График сезонных циклов, message=F, warning=F}
# Исходный ряд
retail_ts %>%
  window(start = 2014) %>%
  ggseasonplot() +
  labs(title = 'Сезонный график (исходный ряд)')
# Ряд с удаленным трендом
retail_detrended %>%
  window(start = 2014) %>%
  ggseasonplot() +
  labs(title = 'Сезонный график (ряд с удаленным трендом)')
```




## STL-декомпозиция

Теперь выполним декомпозицию, используя функцию `forecast::stl()` (*Seasonal and Trend decomposition using Loess*). Данная функция также выделяет тренд с помощью сглаживания, но использует вместо скользящего среднего метод локальной регрессии - LOESS. Это позволяет исключить  потерю данных на концах ряда. Кроме того, метод более устойчив к выбросам в данных ряда. 

Недостатком этого подхода является поддержка сезонности только аддитивного типа. Большинство экономических временных рядов - мультипликативные. 

Для решения этой проблемы можно либо разрешить сезонным компонентам ряда постепенно меняться (используя параметр `s.window` функции `stl()`), либо преобразовать данные, чтобы превратить мультипликативный характер сезонности в аддитивный.

### Изменяющиеся сезонные коэффициенты

Обязательный параметр `s.window` функции `stl()` задает ширину окна для сглаживания ряда методом LOESS при извлечении сезонного компонента. Значение параметра должно быть нечетным и не менее 7. Также можно задать `s.window = 'periodic'`, тогда набор сезонных коэффициентов будет одним и тем же для всех лет.

```{r Влияние ширины окна сглаживания на сезонные индексы}
# Ширина окна сглаживания w задается в цикле
for (w in list(7, 15, 29, 49, 'periodic')) {
  p <- autoplot(seasonal(stl(retail_ts, s.window = w))) +
    labs(title = str_c('s.window = ', w),
         x = NULL, y = 'Сезонный индекс')
  print(p)
}
```

Увеличение ширины окна сглаживания снижает скорость изменения сезонного компонента, однако это приводит к появлению сезонных колебаний в остатках модели.

```{r Влияние ширины окна сглаживания на остатки}
# Ширина окна сглаживания w задается в цикле
for (w in list(7, 15, 29, 49, 'periodic')) {
  p <- autoplot(remainder(stl(retail_ts, s.window = w))) +
    labs(title = str_c('s.window = ', w),
         x = NULL, y = 'Остаток')
  print(p)
}
```

В данном случае ряд изменяется очень быстро, поэтому выберем минимальную ширину окна для сглаживания сезонных индексов - 7.

```{r STL-декомпозиция с изменяющимися сезонными коэффициентами}
retail_stl <- stl(retail_ts, s.window = 7)
```

Как и в случае с классической декомпозицией, отдельные компоненты ряда можно извлечь при помощи функций `seasonal()`, `trendcycle()` и `remainder()`.


```{r График нерегулярного компонента, message=F, warning=F}
retail_stl %>%
  remainder() %>%
  autoplot() +
    labs(title = 'Покупательские подвиги во время кризисов',
         x = NULL, y = 'Остаток') +
    scale_x_continuous(minor_breaks = start(retail_ts):end(retail_ts))
```


Сезонная корректировка ряда позволяет увидеть эти пики в масштабе исходных данных.

```{r Сезонная корректировка ряда методом STL, message= F, warning=F}
autoplot(retail_ts, series = 'Оригинал') +
  autolayer(seasadj(retail_stl), series = 'СС ряд') +
  scale_colour_manual(values = c('lightskyblue', 'brown')) +
  labs(x = NULL, y = NULL, title = retail_title, color = NULL) +
  scale_x_continuous(minor_breaks = start(retail_ts):end(retail_ts))
```

### Логарифмирование

Другой способ обойти проблему мультипликативной сезонности - преобразование данных. При логарифмировании произведение компонент ряда заменяется на сумму логарифмов:

$$ y = T \cdot S \cdot E \Rightarrow  \log y = \log T + \log S + \log E $$

```{r График ряда после логарифмирования}
autoplot(log10(retail_ts)) +
  labs(title = 'Десятичный логарифм оборота розничной торговли',
       x = NULL) +
  geom_line(color = 'darkgray')
```


Аддитивная модель лучше подходит к преобразованным с помощью логарифмирования данным. 



```{r STL-декомпозиция логарифмированного ряда}
retail_stl_log <- 
  retail_ts %>% 
  log10() %>% 
  stl(s.window = 'periodic')
autoplot(retail_stl_log)
```

Данный подход неудобен тем, что для визуализации компонентов в исходном масштабе необходимо обратное преобразование - вычисление показательной функции. Также этот метод не применим, когда в исходных данных содержатся нули.


Чтобы сравнить модель ряда с исходными данными, необходимо выполнить обратное преобразование компонентов ряда - $10^x$.

```{r Сравнение оригинального ряда и модели}
retail_stl_fit <- 10^(trendcycle(retail_stl_log) + 
                    seasonal(retail_stl_log))
autoplot(retail_ts, series = 'Оригинал') +
  autolayer(retail_stl_fit, series = 'Модель') + 
  scale_colour_manual(values = c('dodgerblue', 'lightskyblue')) +
  labs(y = NULL, color = NULL, x = NULL,
       title = retail_title)
```


### Преобразование Бокса-Кокса

Помимо логарифмирования, можно применять и другие преобразования ряда, чтобы уменьшить зависимость амплитуды колебаний от уровня ряда. Например, применяются **степенные преобразования** (**power transformations**):  

$$w_t = y_t ^ {p},$$


где $$p \in \{\frac{1}{2}, \frac{1}{3}, -1 \}. $$

Бокс и Кокс предложили удобный способ описания целого семейства преобразований, включающего степенные преобразования и логарифмирование с помощью параметра $\lambda$. 

**Преобразование Бокса-Кокса** (**Box-Cox transformation**) задается следующим образом:

$$
 w_t = 
  \begin{cases} 
   \log{y} &   \text{при } \lambda = 0 \\
   (y_t^\lambda - 1) / \lambda & \text{иначе.}
  \end{cases}
$$

Логарфм используется натуральный.

Для преобразования временных рядов в R имеется функция `forecast::BoxCox()`.

```{r Преобразования Бокса-Кокса}
# Параметр преобразования изменяется в цикле
for (lambda in c(-1, -0.5, -0.25, 0, 0.25, 0.5, 1)) {
  p <- autoplot(BoxCox(retail_ts, lambda)) +
    labs(title = str_c('lambda = ', lambda),
         x = NULL, y = NULL) +
    geom_line(color = 'darkgray')
  print(p)
  
}
```

Аналогичный пример, демонстрирующий влияние параметра $\lambda$, можно посмотреть [здесь](https://otexts.com/fpp2/transformations.html)

Для автоматического подбора $\lambda$, при котором преобразованный ряд наиболее близок к аддитивной сезонной модели, можно использовать функцию `forecast::BoxCox.lambda()`. О применяемых методах подбора параметра $\lambda$ можно прочитать в справке.

```{r Автоматический подбор параметра преобразования Бокса-Кокса}
best_lambda <- BoxCox.lambda(retail_ts)
autoplot(BoxCox(retail_ts, best_lambda)) + 
    labs(title = paste('lambda = ', round(best_lambda, 2)),
         x = NULL, y = NULL)
```

Полученное в результате подбора значение параметра можно использовать в качестве ориентира, поскольку дробные значения $\lambda$ затрудняют интерпретацию данных. Например, $\lambda = 0.42$ лучше заменить на $\lambda = 0.5$ (квадратный корень).

В данном случае значение параметра $\lambda$ близко к нулю, следовательно для преобразования лучше всего применять логарифмирование.


Чтобы перейти от преобразованных данных назад к исходным, необходимо применить обратное преобразование (**back-transform**). Математически **обратное преобразование Бокса-Кокса** (**reverse Box-Cox transformation**) задается следующим образом:

$$
 y_t = 
  \begin{cases} 
   \exp(w_t) &   \text{при } \lambda = 0 \\
   (\lambda w_t + 1) ^ \frac{1}{\lambda}  & \text{иначе.}
  \end{cases}
$$

В R для обратного преобразования Бокса-Кокса используется функция `forecast::InvBoxCox()`.

При использовании преобразований Бокса-Кокса помните о следующих его особенностях:

- При наличии во временном ряде отрицательных или нулевых значений преобразование невозможно. Однако можно прибавить константу ко всем значения ряда, чтобы исключить отрицательные значения.
- Выбирайте легко интерпретируемые значения $\lambda$ (0.37 -> 0.33, или кубический корень).
- Методы прогнозирования слабо чувствительны к изменению параметра $\lambda$
- Часто преобразование не требуется
- Преобразование иногда практически не изменяет точечный прогноз, но сильно влияет на доверительные интервалы для прогноза.

## Дефляция

За период с 2000 года оборот (в текущих ценах) вырос в 30 раз. Однако для российской экономики характерна инфляция, поэтому в значительной степени увеличение оборота связано с ростом цен на товары, а не увеличением благосостояния и покупательской способности людей.


```{r}
autoplot(retail_ts) +
  labs(title = retail_title, caption = retail_source, x = NULL, y = NULL) +
  geom_line(color = 'lightSkyblue')
```


# Индекс-дефлятор

Чтобы исключить эффект инфляции при анализе временных рядов применяется корректировка данных ряда, основанная на использовании индекса-дефлятора. В качестве такого индекса можно использовать индекс потребительских цен, который агрегированно отражает рост цен на потребительские товары.

В этом примере мы используем индекс потребительских цен, загруженный с сайта Росстата. Исходные данные находятся в файле 
[data/gks_cpi.xlsx](data/gks_cpi.xlsx)

Загрузим эти данные.

```{r Загрузка индекса потребительских цен}
cpi_raw <- read_excel('data/gks_cpi.xlsx', skip = 2)
cpi_raw %>% head
```

Исправим имя первого столбца
```{r}
names(cpi_raw)[1] <- 'year'
```


Данные представляют собой сводную 2D-таблицу, которую надо привести к длинному формату. Также для удобства необходимо создать поле с датой.

```{r}
cpi_tbl <- 
  cpi_raw %>%
  gather(key = 'month', value = 'cpi', -1) %>%
  mutate(date = ymd(paste(year, month, 1))) %>%
  select(date, cpi) %>%
  arrange(date)
cpi_tbl %>% head()
```



```{r, message=F, warning=F}
cpi_tbl %>%
  ggplot(aes(date, cpi)) + 
  geom_line() +
  labs(title = 'Индекс потребительских цен, цепной', x = NULL, y = NULL)
```


Индекс потребительских цен в базе - цепной, т.е. его значения - это процентное изменение по сравнению с предыдущим периодом. В таком виде данные использовать неудобно, требуется пересчитать значения индекса к некоторому базовому периоду. 

Примем за базисный период январь 2002 года - начало данных по индексу потребительских цен.
Для остальных периодов базисный индекс будет равен прозведению с нарастающим итогом цепных индексов текущего и всех предыдущих периодов.


```{r}
cpi_tbl[1, 'cpi'] = 100
cpi_tbl <- 
  cpi_tbl %>%
  mutate(cpi_base = cumprod(cpi/100))
cpi_tbl %>% head()
```




Создадим временной ряд `ts` для индекса потребительских цен:

```{r}
cpi_ts <- 
  cpi_tbl$cpi_base %>%
  ts(start = c(2002, 1), frequency = 12)
cpi_ts %>%
  autoplot() +
  labs(x = NULL, 
       title = 'Индекс-дефлятор цен, базисный')
```



# Рост оборота розничной торговли с учетом инфляции

Получив индекс-дефлятор, можем исключить эффект инфляции при анализе данных об обороте розничной торговли.

```{r Оборот розничной торговли с учетом инфляции}
autoplot(retail_ts/cpi_ts) +
  labs(title = 'Оборот розничной торговли в ценах 2000 года, млрд. руб',
       x = NULL, y = NULL)
```

После исключения эффекта инфляции видно, что рост оборота в отрасли значительно скромнее - порядка 2 раз, с 2002 года.

Для сравнения, построим исходный и скорректированный ряды в одном масштабе:

```{r Эффект инфляции}
autoplot(retail_ts, series = 'в текущих ценах') +
  autolayer(retail_ts/cpi_ts, series = 'в ценах 2002 г') +
  labs(title = 'Оборот розничной торговли, млрд. руб',
       x = NULL, y = NULL, color = NULL,
       caption = 'Источник: ЕМИСС, Росстат')
```

Обратите внимание, что после дефляции ряд стал короче. Причина в том, что значения индекса-дефлятора были известны с 2002 года.
Благодаря наличию индексов, несмотря на разную длину временных рядов, периоды для расчета были сопоставлены правильно.

```{r}
cbind(retail_ts, cpi_ts) %>% head(25)
```
